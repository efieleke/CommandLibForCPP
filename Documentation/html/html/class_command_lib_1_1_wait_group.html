<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CommandLibForCPP: CommandLib::WaitGroup Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CommandLibForCPP
   &#160;<span id="projectnumber">1</span>
   </div>
   <div id="projectbrief">Library for coordinating asynchronous and synchronous actions</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_command_lib.html">CommandLib</a></li><li class="navelem"><a class="el" href="class_command_lib_1_1_wait_group.html">WaitGroup</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_command_lib_1_1_wait_group-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CommandLib::WaitGroup Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class attempts to provide functionality like Windows' WaitForMultipleObjects. It provides a way to efficiently wait upon any number of <a class="el" href="class_command_lib_1_1_waitable.html" title="This class represents an object that can be waited upon until it enters a signaled state...">Waitable</a> objects, until either one or all of the objects enter a signaled state.  
 <a href="class_command_lib_1_1_wait_group.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_wait_group_8h_source.html">WaitGroup.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a813fba9c0d92994c177eee9e6289dc74"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_wait_group.html#a813fba9c0d92994c177eee9e6289dc74">WaitGroup</a> ()</td></tr>
<tr class="memdesc:a813fba9c0d92994c177eee9e6289dc74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contructs a <a class="el" href="class_command_lib_1_1_wait_group.html" title="This class attempts to provide functionality like Windows&#39; WaitForMultipleObjects. It provides a way to efficiently wait upon any number of Waitable objects, until either one or all of the objects enter a signaled state. ">WaitGroup</a> <a href="#a813fba9c0d92994c177eee9e6289dc74">More...</a><br /></td></tr>
<tr class="separator:a813fba9c0d92994c177eee9e6289dc74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad37bdf4b472ad67c660ceb2a9ca0c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_wait_group.html#a2ad37bdf4b472ad67c660ceb2a9ca0c9">AddWaitable</a> (<a class="el" href="class_command_lib_1_1_waitable.html#ac74b6b91e48220146eada76a31cf2d9b">Waitable::Ptr</a> waitable)</td></tr>
<tr class="memdesc:a2ad37bdf4b472ad67c660ceb2a9ca0c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <a class="el" href="class_command_lib_1_1_waitable.html" title="This class represents an object that can be waited upon until it enters a signaled state...">Waitable</a> to this <a class="el" href="class_command_lib_1_1_wait_group.html" title="This class attempts to provide functionality like Windows&#39; WaitForMultipleObjects. It provides a way to efficiently wait upon any number of Waitable objects, until either one or all of the objects enter a signaled state. ">WaitGroup</a> <a href="#a2ad37bdf4b472ad67c660ceb2a9ca0c9">More...</a><br /></td></tr>
<tr class="separator:a2ad37bdf4b472ad67c660ceb2a9ca0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa119ca1edda12cc5b33602801b399839"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_wait_group.html#aa119ca1edda12cc5b33602801b399839">WaitForAny</a> () const</td></tr>
<tr class="memdesc:aa119ca1edda12cc5b33602801b399839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until any one of the waitable objects becomes signaled. <a href="#aa119ca1edda12cc5b33602801b399839">More...</a><br /></td></tr>
<tr class="separator:aa119ca1edda12cc5b33602801b399839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607e5738e2ef6d34c70459954a752340"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:a607e5738e2ef6d34c70459954a752340"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_wait_group.html#a607e5738e2ef6d34c70459954a752340">WaitForAny</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;dur) const</td></tr>
<tr class="memdesc:a607e5738e2ef6d34c70459954a752340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until any one of the waitable objects becomes signaled. <a href="#a607e5738e2ef6d34c70459954a752340">More...</a><br /></td></tr>
<tr class="separator:a607e5738e2ef6d34c70459954a752340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c31c5a9acfaf1df818d22919a976ee2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_wait_group.html#a8c31c5a9acfaf1df818d22919a976ee2">WaitForAny</a> (long long ms) const</td></tr>
<tr class="memdesc:a8c31c5a9acfaf1df818d22919a976ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until any one of the waitable objects becomes signaled. <a href="#a8c31c5a9acfaf1df818d22919a976ee2">More...</a><br /></td></tr>
<tr class="separator:a8c31c5a9acfaf1df818d22919a976ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb05642c6c71d13c0e809f429c4baa0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_wait_group.html#a4fb05642c6c71d13c0e809f429c4baa0">WaitForAll</a> () const</td></tr>
<tr class="memdesc:a4fb05642c6c71d13c0e809f429c4baa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until all of the waitable objects have entered the signaled state. <a href="#a4fb05642c6c71d13c0e809f429c4baa0">More...</a><br /></td></tr>
<tr class="separator:a4fb05642c6c71d13c0e809f429c4baa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490ab91ba70877fa5aa6567fbfdec9ad"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:a490ab91ba70877fa5aa6567fbfdec9ad"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_wait_group.html#a490ab91ba70877fa5aa6567fbfdec9ad">WaitForAll</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;dur) const</td></tr>
<tr class="memdesc:a490ab91ba70877fa5aa6567fbfdec9ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until all of the waitable objects have entered the signaled state. <a href="#a490ab91ba70877fa5aa6567fbfdec9ad">More...</a><br /></td></tr>
<tr class="separator:a490ab91ba70877fa5aa6567fbfdec9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5c6931a0eb4948a9341a8faa3c26ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_wait_group.html#a9f5c6931a0eb4948a9341a8faa3c26ce">WaitForAll</a> (long long ms) const</td></tr>
<tr class="memdesc:a9f5c6931a0eb4948a9341a8faa3c26ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until all of the waitable objects are simulataneously signaled. <a href="#a9f5c6931a0eb4948a9341a8faa3c26ce">More...</a><br /></td></tr>
<tr class="separator:a9f5c6931a0eb4948a9341a8faa3c26ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class attempts to provide functionality like Windows' WaitForMultipleObjects. It provides a way to efficiently wait upon any number of <a class="el" href="class_command_lib_1_1_waitable.html" title="This class represents an object that can be waited upon until it enters a signaled state...">Waitable</a> objects, until either one or all of the objects enter a signaled state. </p>
<p>Behavior is undefined if you access the same <a class="el" href="class_command_lib_1_1_wait_group.html" title="This class attempts to provide functionality like Windows&#39; WaitForMultipleObjects. It provides a way to efficiently wait upon any number of Waitable objects, until either one or all of the objects enter a signaled state. ">WaitGroup</a> object across multiple threads.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a813fba9c0d92994c177eee9e6289dc74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a813fba9c0d92994c177eee9e6289dc74">&#9670;&nbsp;</a></span>WaitGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CommandLib::WaitGroup::WaitGroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Contructs a <a class="el" href="class_command_lib_1_1_wait_group.html" title="This class attempts to provide functionality like Windows&#39; WaitForMultipleObjects. It provides a way to efficiently wait upon any number of Waitable objects, until either one or all of the objects enter a signaled state. ">WaitGroup</a></p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2ad37bdf4b472ad67c660ceb2a9ca0c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad37bdf4b472ad67c660ceb2a9ca0c9">&#9670;&nbsp;</a></span>AddWaitable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommandLib::WaitGroup::AddWaitable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_command_lib_1_1_waitable.html#ac74b6b91e48220146eada76a31cf2d9b">Waitable::Ptr</a>&#160;</td>
          <td class="paramname"><em>waitable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a <a class="el" href="class_command_lib_1_1_waitable.html" title="This class represents an object that can be waited upon until it enters a signaled state...">Waitable</a> to this <a class="el" href="class_command_lib_1_1_wait_group.html" title="This class attempts to provide functionality like Windows&#39; WaitForMultipleObjects. It provides a way to efficiently wait upon any number of Waitable objects, until either one or all of the objects enter a signaled state. ">WaitGroup</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waitable</td><td>The object to include in the group wait.</td></tr>
  </table>
  </dd>
</dl>
<p>This object must remain in scope for as long as the item passed as a parameter, otherwise behavior is undefined. </p>

</div>
</div>
<a id="a4fb05642c6c71d13c0e809f429c4baa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb05642c6c71d13c0e809f429c4baa0">&#9670;&nbsp;</a></span>WaitForAll() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommandLib::WaitGroup::WaitForAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits until all of the waitable objects have entered the signaled state.</p>
<p>Note that this will return after all of the items have been in the signaled at any time since the wait began. This does <em>not</em> wait until the items are simultaneously signaled. For example, if waiting upon two events, and the first becomes signaled, and is then reset, and then the second event becomes signaled, this method will return (even though the two events were never both in the signaled state at the same time). </p>

</div>
</div>
<a id="a490ab91ba70877fa5aa6567fbfdec9ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a490ab91ba70877fa5aa6567fbfdec9ad">&#9670;&nbsp;</a></span>WaitForAll() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , typename Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CommandLib::WaitGroup::WaitForAll </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>dur</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits until all of the waitable objects have entered the signaled state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dur</td><td>The maximum amount of time to wait</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all objects have entered the signaled state at some point before the duration expires, false otherwise </dd></dl>
<p>Note that this will return after all of the items have been in the signaled at any time since the wait began (or the duration elapses). This does <em>not</em> wait until the items are simultaneously signaled. For example, if waiting upon two events, and the first becomes signaled, and is then reset, and then the second event becomes signaled, this method will return (even though the two events were never both in the signaled state at the same time). </p>

</div>
</div>
<a id="a9f5c6931a0eb4948a9341a8faa3c26ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5c6931a0eb4948a9341a8faa3c26ce">&#9670;&nbsp;</a></span>WaitForAll() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CommandLib::WaitGroup::WaitForAll </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits until all of the waitable objects are simulataneously signaled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>The maximum amount of milliseconds to wait</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all objects are simultaneously signaled before the duration expires, false otherwise</dd></dl>
<p>Note that this will return after all of the items have been in the signaled at any time since the wait began, or the duration elapses. This does <em>not</em> wait until the items are simultaneously signaled.For example, if waiting upon two events, and the first becomes signaled, and is then reset, and then the second event becomes signaled, this method will return (even though the two events were never both in the signaled state at the same time). </p>

</div>
</div>
<a id="aa119ca1edda12cc5b33602801b399839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa119ca1edda12cc5b33602801b399839">&#9670;&nbsp;</a></span>WaitForAny() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CommandLib::WaitGroup::WaitForAny </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits until any one of the waitable objects becomes signaled.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the first item to become signaled (<a class="el" href="class_command_lib_1_1_wait_group.html#a2ad37bdf4b472ad67c660ceb2a9ca0c9" title="Adds a Waitable to this WaitGroup">AddWaitable</a> adds items in sequential order). </dd></dl>
<p>If multiple items are simultaneously signaled, this will return the one with the lowest index </p>

</div>
</div>
<a id="a607e5738e2ef6d34c70459954a752340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a607e5738e2ef6d34c70459954a752340">&#9670;&nbsp;</a></span>WaitForAny() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , typename Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CommandLib::WaitGroup::WaitForAny </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>dur</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits until any one of the waitable objects becomes signaled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dur</td><td>The maximum amount of time to wait</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">The index of the first item to become signaled (<a class="el" href="class_command_lib_1_1_wait_group.html#a2ad37bdf4b472ad67c660ceb2a9ca0c9" title="Adds a Waitable to this WaitGroup">AddWaitable</a> adds items in sequential order). If none of the items are signaled before the duration elapses, this will return -1. </p>
<p class="enddd">If multiple items are simultaneously signaled, this will return the one with the lowest index </p>
</dd></dl>

</div>
</div>
<a id="a8c31c5a9acfaf1df818d22919a976ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c31c5a9acfaf1df818d22919a976ee2">&#9670;&nbsp;</a></span>WaitForAny() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CommandLib::WaitGroup::WaitForAny </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits until any one of the waitable objects becomes signaled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>The maximum amount of time to wait</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first item to become signaled (<a class="el" href="class_command_lib_1_1_wait_group.html#a2ad37bdf4b472ad67c660ceb2a9ca0c9" title="Adds a Waitable to this WaitGroup">AddWaitable</a> adds items in sequential order). If none of the items are signaled before the duration elapses, this will return -1. </dd></dl>
<p>If multiple items are simultaneously signaled, this will return the one with the lowest index </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/efieleke/Documents/GitHub/CommandLibForCPP/CommandLib/include/<a class="el" href="_wait_group_8h_source.html">WaitGroup.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
