<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CommandLib: CommandLib::CommandDispatcher Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CommandLib
   </div>
   <div id="projectbrief">Classes that simplify coordination of asynchronous and synchronous activities</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_command_lib.html">CommandLib</a></li><li class="navelem"><a class="el" href="class_command_lib_1_1_command_dispatcher.html">CommandDispatcher</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_command_lib_1_1_command_dispatcher-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CommandLib::CommandDispatcher Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Dispatches <a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a> objects for asynchronous execution.  
 <a href="class_command_lib_1_1_command_dispatcher.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_command_dispatcher_8h_source.html">CommandDispatcher.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9ef89de55c915fbd5f2e61784d67d8a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command_dispatcher.html#a9ef89de55c915fbd5f2e61784d67d8a0">CommandDispatcher</a> (size_t maxConcurrent)</td></tr>
<tr class="memdesc:a9ef89de55c915fbd5f2e61784d67d8a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="class_command_lib_1_1_command_dispatcher.html" title="Dispatches Command objects for asynchronous execution.">CommandDispatcher</a> object  <a href="class_command_lib_1_1_command_dispatcher.html#a9ef89de55c915fbd5f2e61784d67d8a0">More...</a><br /></td></tr>
<tr class="separator:a9ef89de55c915fbd5f2e61784d67d8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2995e97c734165b7d0b3491d606c547b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command_dispatcher.html#a2995e97c734165b7d0b3491d606c547b">AddMonitor</a> (<a class="el" href="class_command_lib_1_1_command_monitor.html">CommandMonitor</a> *monitor)</td></tr>
<tr class="memdesc:a2995e97c734165b7d0b3491d606c547b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a listener that will receive callbacks about the status of commands executed by this dispatcher  <a href="class_command_lib_1_1_command_dispatcher.html#a2995e97c734165b7d0b3491d606c547b">More...</a><br /></td></tr>
<tr class="separator:a2995e97c734165b7d0b3491d606c547b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1db45e830c48a4085bb2b86e47c692"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command_dispatcher.html#a2a1db45e830c48a4085bb2b86e47c692">Dispatch</a> (<a class="el" href="class_command_lib_1_1_command.html#a3b3e4f00144373299df5c6bb1acc319d">Command::Ptr</a> command)</td></tr>
<tr class="memdesc:a2a1db45e830c48a4085bb2b86e47c692"><td class="mdescLeft">&#160;</td><td class="mdescRight">If there is room in the pool, asynchronously executes the command immediately. Otherwise, places the command in a queue for processing when room in the pool becomes available.  <a href="class_command_lib_1_1_command_dispatcher.html#a2a1db45e830c48a4085bb2b86e47c692">More...</a><br /></td></tr>
<tr class="separator:a2a1db45e830c48a4085bb2b86e47c692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1b36f9203de1426d7dff4f83808bec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command_dispatcher.html#ade1b36f9203de1426d7dff4f83808bec">Abort</a> ()</td></tr>
<tr class="memdesc:ade1b36f9203de1426d7dff4f83808bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts all dispatched commands, and empties the queue of not yet executed commands.  <a href="class_command_lib_1_1_command_dispatcher.html#ade1b36f9203de1426d7dff4f83808bec">More...</a><br /></td></tr>
<tr class="separator:ade1b36f9203de1426d7dff4f83808bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f8cae272c637ac628977c1556171c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command_dispatcher.html#ad5f8cae272c637ac628977c1556171c6">Wait</a> ()</td></tr>
<tr class="memdesc:ad5f8cae272c637ac628977c1556171c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for all dispatched commands to finish execution  <a href="class_command_lib_1_1_command_dispatcher.html#ad5f8cae272c637ac628977c1556171c6">More...</a><br /></td></tr>
<tr class="separator:ad5f8cae272c637ac628977c1556171c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324fd9debb368929cbc5357440bd8111"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command_dispatcher.html#a324fd9debb368929cbc5357440bd8111">AbortAndWait</a> ()</td></tr>
<tr class="memdesc:a324fd9debb368929cbc5357440bd8111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exact same effect as calling <a class="el" href="class_command_lib_1_1_command_dispatcher.html#ade1b36f9203de1426d7dff4f83808bec" title="Aborts all dispatched commands, and empties the queue of not yet executed commands.">Abort</a> followed immediately by a call to <a class="el" href="class_command_lib_1_1_command_dispatcher.html#ad5f8cae272c637ac628977c1556171c6" title="Waits for all dispatched commands to finish execution">Wait</a>.  <a href="class_command_lib_1_1_command_dispatcher.html#a324fd9debb368929cbc5357440bd8111">More...</a><br /></td></tr>
<tr class="separator:a324fd9debb368929cbc5357440bd8111"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Dispatches <a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a> objects for asynchronous execution. </p>
<p>This class can be useful when commands are dynamically generated at runtime, and must be dynamically executed upon generation. (for example, asynchronous handling of requests sent over a data stream). </p>
<p>Upon destruction, this object will wait until all dispatched commands finish execution. For a faster shutdown, you may wish to call <a class="el" href="class_command_lib_1_1_command_dispatcher.html#ade1b36f9203de1426d7dff4f83808bec" title="Aborts all dispatched commands, and empties the queue of not yet executed commands.">CommandDispatcher::Abort()</a> before destructing the dispatcher. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9ef89de55c915fbd5f2e61784d67d8a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef89de55c915fbd5f2e61784d67d8a0">&#9670;&nbsp;</a></span>CommandDispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CommandLib::CommandDispatcher::CommandDispatcher </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxConcurrent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="class_command_lib_1_1_command_dispatcher.html" title="Dispatches Command objects for asynchronous execution.">CommandDispatcher</a> object </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxConcurrent</td><td>The maximum number of commands that can be executed concurrently by this dispatcher. If this limit is reached, commands will be queued and only executed when enough prior dispatched commands finish execution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ade1b36f9203de1426d7dff4f83808bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade1b36f9203de1426d7dff4f83808bec">&#9670;&nbsp;</a></span>Abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommandLib::CommandDispatcher::Abort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aborts all dispatched commands, and empties the queue of not yet executed commands. </p>

</div>
</div>
<a id="a324fd9debb368929cbc5357440bd8111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324fd9debb368929cbc5357440bd8111">&#9670;&nbsp;</a></span>AbortAndWait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommandLib::CommandDispatcher::AbortAndWait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exact same effect as calling <a class="el" href="class_command_lib_1_1_command_dispatcher.html#ade1b36f9203de1426d7dff4f83808bec" title="Aborts all dispatched commands, and empties the queue of not yet executed commands.">Abort</a> followed immediately by a call to <a class="el" href="class_command_lib_1_1_command_dispatcher.html#ad5f8cae272c637ac628977c1556171c6" title="Waits for all dispatched commands to finish execution">Wait</a>. </p>

</div>
</div>
<a id="a2995e97c734165b7d0b3491d606c547b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2995e97c734165b7d0b3491d606c547b">&#9670;&nbsp;</a></span>AddMonitor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommandLib::CommandDispatcher::AddMonitor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_command_lib_1_1_command_monitor.html">CommandMonitor</a> *&#160;</td>
          <td class="paramname"><em>monitor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a listener that will receive callbacks about the status of commands executed by this dispatcher </p>

</div>
</div>
<a id="a2a1db45e830c48a4085bb2b86e47c692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a1db45e830c48a4085bb2b86e47c692">&#9670;&nbsp;</a></span>Dispatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommandLib::CommandDispatcher::Dispatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_command_lib_1_1_command.html#a3b3e4f00144373299df5c6bb1acc319d">Command::Ptr</a>&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If there is room in the pool, asynchronously executes the command immediately. Otherwise, places the command in a queue for processing when room in the pool becomes available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The command to execute as soon as there is room in the pool. The command must be top-level (that is, it must have no parent). </td></tr>
  </table>
  </dd>
</dl>
<p>Note that it will cause undefined behavior to dispatch a <a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a> object that is currently executing, or that has already been dispatched but has not yet executed. </p>
<p>When the command evenutally finishes execution, the <a class="el" href="class_command_lib_1_1_command_monitor.html" title="This is a callback interface for Command starting and finishing events. Its intended use is for loggi...">CommandMonitor</a> subscribers will be notified on a different thread. </p>

</div>
</div>
<a id="ad5f8cae272c637ac628977c1556171c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f8cae272c637ac628977c1556171c6">&#9670;&nbsp;</a></span>Wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommandLib::CommandDispatcher::Wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for all dispatched commands to finish execution </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/efiel/source/repos/efieleke/CommandLibForCPP/CommandLib/include/<a class="el" href="_command_dispatcher_8h_source.html">CommandDispatcher.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
