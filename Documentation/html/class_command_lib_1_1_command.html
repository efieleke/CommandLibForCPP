<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>CommandLibForCPP: CommandLib::Command Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CommandLibForCPP
   &#160;<span id="projectnumber">1.0.0.0</span>
   </div>
   <div id="projectbrief">Classes to simplify coordination of asynchronous and synchronous actions</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_command_lib_1_1_command.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_command_lib_1_1_command-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CommandLib::Command Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents an action that can be run synchronously or asynchronously. 
 <a href="class_command_lib_1_1_command.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_command_8h_source.html">Command.h</a>&gt;</code></p>

<p>Inherits enable_shared_from_this&lt; Command &gt;.</p>

<p>Inherited by <a class="el" href="class_command_lib_1_1_async_command.html">CommandLib::AsyncCommand</a>, <a class="el" href="class_command_lib_1_1_sync_command.html">CommandLib::SyncCommand</a>, and <a class="el" href="class_command_lib_1_1_variable_command.html">CommandLib::VariableCommand</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aee8fd78ff853a1f9c8e56959c3e81811"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; const <br class="typebreak" />
<a class="el" href="class_command_lib_1_1_command.html">Command</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#aee8fd78ff853a1f9c8e56959c3e81811">ConstPtr</a></td></tr>
<tr class="memdesc:aee8fd78ff853a1f9c8e56959c3e81811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer to a non-modifyable <a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a> object <a href="#aee8fd78ff853a1f9c8e56959c3e81811">More...</a><br /></td></tr>
<tr class="separator:aee8fd78ff853a1f9c8e56959c3e81811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3e4f00144373299df5c6bb1acc319d"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; <a class="el" href="class_command_lib_1_1_command.html">Command</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a3b3e4f00144373299df5c6bb1acc319d">Ptr</a></td></tr>
<tr class="memdesc:a3b3e4f00144373299df5c6bb1acc319d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer to a <a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a> object <a href="#a3b3e4f00144373299df5c6bb1acc319d">More...</a><br /></td></tr>
<tr class="separator:a3b3e4f00144373299df5c6bb1acc319d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a04e911cc1a65438fd78d8d1d81f6faaa"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a04e911cc1a65438fd78d8d1d81f6faaa">Id</a> () const </td></tr>
<tr class="memdesc:a04e911cc1a65438fd78d8d1d81f6faaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unique identifier for this command <a href="#a04e911cc1a65438fd78d8d1d81f6faaa">More...</a><br /></td></tr>
<tr class="separator:a04e911cc1a65438fd78d8d1d81f6faaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6772eb611b09f4fdb3812fa059d82555"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_command_lib_1_1_command.html">Command</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a6772eb611b09f4fdb3812fa059d82555">Parent</a> () const </td></tr>
<tr class="memdesc:a6772eb611b09f4fdb3812fa059d82555"><td class="mdescLeft">&#160;</td><td class="mdescRight">The command under which this command is nested, if any <a href="#a6772eb611b09f4fdb3812fa059d82555">More...</a><br /></td></tr>
<tr class="separator:a6772eb611b09f4fdb3812fa059d82555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d249e5aecce7e36de8fd4495ae38da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a84d249e5aecce7e36de8fd4495ae38da">Depth</a> () const </td></tr>
<tr class="memdesc:a84d249e5aecce7e36de8fd4495ae38da"><td class="mdescLeft">&#160;</td><td class="mdescRight">How deeply nested this command is <a href="#a84d249e5aecce7e36de8fd4495ae38da">More...</a><br /></td></tr>
<tr class="separator:a84d249e5aecce7e36de8fd4495ae38da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67806612c49e59e3df7310774ca6403b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a67806612c49e59e3df7310774ca6403b">Description</a> () const </td></tr>
<tr class="memdesc:a67806612c49e59e3df7310774ca6403b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A description of the <a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a> <a href="#a67806612c49e59e3df7310774ca6403b">More...</a><br /></td></tr>
<tr class="separator:a67806612c49e59e3df7310774ca6403b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c23bbfb9fd781210f36a6a76129c77"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a89c23bbfb9fd781210f36a6a76129c77">ExtendedDescription</a> () const </td></tr>
<tr class="memdesc:a89c23bbfb9fd781210f36a6a76129c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the command (beyond its type and id), if available, for diagnostic purposes.  <a href="#a89c23bbfb9fd781210f36a6a76129c77">More...</a><br /></td></tr>
<tr class="separator:a89c23bbfb9fd781210f36a6a76129c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d33760ccb927d7f6349c02907ab4ff3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a5d33760ccb927d7f6349c02907ab4ff3">SyncExecute</a> ()</td></tr>
<tr class="memdesc:a5d33760ccb927d7f6349c02907ab4ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the command and does not return until it finishes. <a href="#a5d33760ccb927d7f6349c02907ab4ff3">More...</a><br /></td></tr>
<tr class="separator:a5d33760ccb927d7f6349c02907ab4ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bad231a0f0a6de3d5405382d95f800"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a44bad231a0f0a6de3d5405382d95f800">AsyncExecute</a> (<a class="el" href="class_command_lib_1_1_command_listener.html">CommandListener</a> *listener)</td></tr>
<tr class="memdesc:a44bad231a0f0a6de3d5405382d95f800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts executing the command and returns immediately.  <a href="#a44bad231a0f0a6de3d5405382d95f800">More...</a><br /></td></tr>
<tr class="separator:a44bad231a0f0a6de3d5405382d95f800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247cbc7325e3b9d9d7044d449b989aa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a247cbc7325e3b9d9d7044d449b989aa6">Abort</a> ()</td></tr>
<tr class="memdesc:a247cbc7325e3b9d9d7044d449b989aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts a running command <a href="#a247cbc7325e3b9d9d7044d449b989aa6">More...</a><br /></td></tr>
<tr class="separator:a247cbc7325e3b9d9d7044d449b989aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0d288fa3168a371238b53e3f4a90f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#adb0d288fa3168a371238b53e3f4a90f7">Wait</a> () const </td></tr>
<tr class="memdesc:adb0d288fa3168a371238b53e3f4a90f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for a running command to complete. Will return immediately if the command is not currently executing.  <a href="#adb0d288fa3168a371238b53e3f4a90f7">More...</a><br /></td></tr>
<tr class="separator:adb0d288fa3168a371238b53e3f4a90f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109ddf04b5f404e5194e5a3c910a378b"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:a109ddf04b5f404e5194e5a3c910a378b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a109ddf04b5f404e5194e5a3c910a378b">Wait</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;interval) const </td></tr>
<tr class="memdesc:a109ddf04b5f404e5194e5a3c910a378b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits a specified duration for a running command to complete. Will return immediately if the command is not currently executing.  <a href="#a109ddf04b5f404e5194e5a3c910a378b">More...</a><br /></td></tr>
<tr class="separator:a109ddf04b5f404e5194e5a3c910a378b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c65836e7c908923127ff9bba6d4d5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a18c65836e7c908923127ff9bba6d4d5b">Wait</a> (long long milliseconds) const </td></tr>
<tr class="memdesc:a18c65836e7c908923127ff9bba6d4d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits the specified milliseconds for a running command to complete. Will return immediately if the command is not currently executing.  <a href="#a18c65836e7c908923127ff9bba6d4d5b">More...</a><br /></td></tr>
<tr class="separator:a18c65836e7c908923127ff9bba6d4d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6afa9e7eab83d5e59746fe15e295e066"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a6afa9e7eab83d5e59746fe15e295e066">AbortAndWait</a> ()</td></tr>
<tr class="memdesc:a6afa9e7eab83d5e59746fe15e295e066"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exact same effect as a call to <a class="el" href="class_command_lib_1_1_command.html#a247cbc7325e3b9d9d7044d449b989aa6" title="Aborts a running command">Abort</a> immediately followed by a call to <a class="el" href="class_command_lib_1_1_command.html#adb0d288fa3168a371238b53e3f4a90f7" title="Waits for a running command to complete. Will return immediately if the command is not currently exec...">Wait</a>  <a href="#a6afa9e7eab83d5e59746fe15e295e066">More...</a><br /></td></tr>
<tr class="separator:a6afa9e7eab83d5e59746fe15e295e066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75bcf85f047a0e986568d134236096d"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:aa75bcf85f047a0e986568d134236096d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#aa75bcf85f047a0e986568d134236096d">AbortAndWait</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;interval) const </td></tr>
<tr class="memdesc:aa75bcf85f047a0e986568d134236096d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exact same effect as a call to <a class="el" href="class_command_lib_1_1_command.html#a247cbc7325e3b9d9d7044d449b989aa6" title="Aborts a running command">Abort</a> immediately followed by a call to Wait(const std::chrono::duration{Rep, Period}&amp;)  <a href="#aa75bcf85f047a0e986568d134236096d">More...</a><br /></td></tr>
<tr class="separator:aa75bcf85f047a0e986568d134236096d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e0fd4eb4f1d2b6d98228c1432805e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#ab7e0fd4eb4f1d2b6d98228c1432805e3">AbortAndWait</a> (long long milliseconds)</td></tr>
<tr class="memdesc:ab7e0fd4eb4f1d2b6d98228c1432805e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exact same effect as a call to <a class="el" href="class_command_lib_1_1_command.html#a247cbc7325e3b9d9d7044d449b989aa6" title="Aborts a running command">Abort</a> immediately followed by a call to Wait(const std::chrono::duration{Rep, Period}&amp;)  <a href="#ab7e0fd4eb4f1d2b6d98228c1432805e3">More...</a><br /></td></tr>
<tr class="separator:ab7e0fd4eb4f1d2b6d98228c1432805e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f8ac531b436a41b21252fa2e17fd79"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a96f8ac531b436a41b21252fa2e17fd79">ClassName</a> () const =0</td></tr>
<tr class="memdesc:a96f8ac531b436a41b21252fa2e17fd79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of the runtime instance of this class. Used for logging and diagnostic purposes.  <a href="#a96f8ac531b436a41b21252fa2e17fd79">More...</a><br /></td></tr>
<tr class="separator:a96f8ac531b436a41b21252fa2e17fd79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add579dd7358aa87e722f8b2e9be0afd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_command_lib_1_1_waitable.html#ac74b6b91e48220146eada76a31cf2d9b">Waitable::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#add579dd7358aa87e722f8b2e9be0afd8">DoneEvent</a> () const </td></tr>
<tr class="memdesc:add579dd7358aa87e722f8b2e9be0afd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signaled when this command has finished execution, regardless of whether it succeeded, failed or was aborted.  <a href="#add579dd7358aa87e722f8b2e9be0afd8">More...</a><br /></td></tr>
<tr class="separator:add579dd7358aa87e722f8b2e9be0afd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f49e49de93e9b4ef3093031b41cc551"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_command_lib_1_1_waitable.html#ac74b6b91e48220146eada76a31cf2d9b">Waitable::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a4f49e49de93e9b4ef3093031b41cc551">AbortEvent</a> () const </td></tr>
<tr class="memdesc:a4f49e49de93e9b4ef3093031b41cc551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signaled when this command is to be aborted. Note that this event is only reset when the command next begins execution.  <a href="#a4f49e49de93e9b4ef3093031b41cc551">More...</a><br /></td></tr>
<tr class="separator:a4f49e49de93e9b4ef3093031b41cc551"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aa4ceb8d85a720bc5d9bac4be3afd7df5"><td class="memItemLeft" align="right" valign="top">static std::list<br class="typebreak" />
&lt; <a class="el" href="class_command_lib_1_1_command_monitor.html">CommandMonitor</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#aa4ceb8d85a720bc5d9bac4be3afd7df5">sm_monitors</a></td></tr>
<tr class="memdesc:aa4ceb8d85a720bc5d9bac4be3afd7df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The objects that define command monitoring behavior. Monitoring is meant for logging and diagnostic purposes.  <a href="#aa4ceb8d85a720bc5d9bac4be3afd7df5">More...</a><br /></td></tr>
<tr class="separator:aa4ceb8d85a720bc5d9bac4be3afd7df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a31713edf2ee9c217f9090e5337dd1f44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a31713edf2ee9c217f9090e5337dd1f44">Command</a> ()</td></tr>
<tr class="memdesc:a31713edf2ee9c217f9090e5337dd1f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor  <a href="#a31713edf2ee9c217f9090e5337dd1f44">More...</a><br /></td></tr>
<tr class="separator:a31713edf2ee9c217f9090e5337dd1f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0787e7b79c5424926be5c1c8be1ebb0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a0787e7b79c5424926be5c1c8be1ebb0d">TakeOwnership</a> (<a class="el" href="class_command_lib_1_1_command.html#a3b3e4f00144373299df5c6bb1acc319d">Ptr</a> orphan)</td></tr>
<tr class="memdesc:a0787e7b79c5424926be5c1c8be1ebb0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make this command the owner of the command passed as an argument. <a href="#a0787e7b79c5424926be5c1c8be1ebb0d">More...</a><br /></td></tr>
<tr class="separator:a0787e7b79c5424926be5c1c8be1ebb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac872e76c74ed573668b60351fd9ffd1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#ac872e76c74ed573668b60351fd9ffd1d">RelinquishOwnership</a> (<a class="el" href="class_command_lib_1_1_command.html#a3b3e4f00144373299df5c6bb1acc319d">Ptr</a> command)</td></tr>
<tr class="memdesc:ac872e76c74ed573668b60351fd9ffd1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes what used to be an owned command a top-level command. <a href="#ac872e76c74ed573668b60351fd9ffd1d">More...</a><br /></td></tr>
<tr class="separator:ac872e76c74ed573668b60351fd9ffd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb415e0c75ffbda7cb840443ea4ac885"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#aeb415e0c75ffbda7cb840443ea4ac885">CheckAbortFlag</a> () const </td></tr>
<tr class="memdesc:aeb415e0c75ffbda7cb840443ea4ac885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws a <a class="el" href="class_command_lib_1_1_command_aborted_exception.html" title="This is thrown from Command.SyncExecute() when a command is aborted. ">CommandAbortedException</a> if an abort is pending. Synchronous implementations may find this useful in order to respond to an abort request in a timely manner.  <a href="#aeb415e0c75ffbda7cb840443ea4ac885">More...</a><br /></td></tr>
<tr class="separator:aeb415e0c75ffbda7cb840443ea4ac885"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:abff6f12669682d683b4c150859ce09fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abff6f12669682d683b4c150859ce09fc"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>AsyncCommand</b></td></tr>
<tr class="separator:abff6f12669682d683b4c150859ce09fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents an action that can be run synchronously or asynchronously.</p>
<p>Commands are abortable. Even a synchronously running command can be aborted from a separate thread. </p>
<p><a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a> types are only instantiable via static Create() methods. This is because commands often own other commands. It was necessary to either enforce clone interface support, or enforce working with smart pointers. Smart pointers felt like the easier approach for clients (writing clone methods is a nuisance). </p>
<p>When developing a <a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a> subclass, be sure to inherit from either <a class="el" href="class_command_lib_1_1_sync_command.html" title="Represents a Command which is most naturally synchronous in its implementation. If you inherit from t...">SyncCommand</a> (if your command is naturally synchronous in its implementation) or <a class="el" href="class_command_lib_1_1_async_command.html" title="Represents a Command which is most naturally asynchronous in its implementation. If you inherit from ...">AsyncCommand</a>. Those classes take care of the unnatural implementations (<a class="el" href="class_command_lib_1_1_sync_command.html" title="Represents a Command which is most naturally synchronous in its implementation. If you inherit from t...">SyncCommand</a> implements AsyncExecuteImpl, and <a class="el" href="class_command_lib_1_1_async_command.html" title="Represents a Command which is most naturally asynchronous in its implementation. If you inherit from ...">AsyncCommand</a> implements SyncExecuteImpl). </p>
<p>Also, when developing a <a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a> subclass, make sure that any member variables that are Commands are properly owned by calling see cref="TakeOwnership"/&gt; within your static Create() method. The advantage of doing this is that owned commands will automatically respond to abort requests issued to the owner. </p>
<p>If you write a method that accepts a <a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a> as an argument, you may wish to assume ownership of that <a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a>. <a class="el" href="class_command_lib_1_1_command.html#a0787e7b79c5424926be5c1c8be1ebb0d" title="Make this command the owner of the command passed as an argument.">TakeOwnership</a> allows you to do this. The <a class="el" href="class_command_lib_1_1_sequential_commands.html#af0100e15f7897471ce84802ab6c25e00" title="Adds a Command to the collection to execute.">SequentialCommands::Add</a> member of <a class="el" href="class_command_lib_1_1_sequential_commands.html" title="Represents a collection of Command objects that execute in sequence, wrapped in a Command object...">SequentialCommands</a> is an example of this behavior. </p>
<p>If you would like to create a top level command that responds to abort requests to a different command, create a <a class="el" href="class_command_lib_1_1_abort_linked_command.html" title="A Command wrapper that, in addition to responding to normal Command::Abort requests, also aborts in response to either 1) a request to abort a different, specified Command instance, or 2) the signaling of a specified Waitable (typically an Event). ">AbortLinkedCommand</a>. The use cases of this would be rare, but it can help when command objects must be more loosely coupled. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="aee8fd78ff853a1f9c8e56959c3e81811"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;const <a class="el" href="class_command_lib_1_1_command.html">Command</a>&gt; <a class="el" href="class_command_lib_1_1_command.html#aee8fd78ff853a1f9c8e56959c3e81811">CommandLib::Command::ConstPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared pointer to a non-modifyable <a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a> object</p>

</div>
</div>
<a class="anchor" id="a3b3e4f00144373299df5c6bb1acc319d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;<a class="el" href="class_command_lib_1_1_command.html">Command</a>&gt; <a class="el" href="class_command_lib_1_1_command.html#a3b3e4f00144373299df5c6bb1acc319d">CommandLib::Command::Ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared pointer to a <a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a> object</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a31713edf2ee9c217f9090e5337dd1f44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CommandLib::Command::Command </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a247cbc7325e3b9d9d7044d449b989aa6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommandLib::Command::Abort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aborts a running command</p>
<p>This method will have no effect on a command that is not running (nor will it cause a future execution of this command to abort). Synchronous execution will throw a <a class="el" href="class_command_lib_1_1_command_aborted_exception.html" title="This is thrown from Command.SyncExecute() when a command is aborted. ">CommandAbortedException</a> if aborted, and asynchronous execution will invoke <a class="el" href="class_command_lib_1_1_command_listener.html#aa389ff6dd3895ce4ecc9447a23e4d9fc" title="Called when a Command launched via Command::AsyncExecute(CommandListener*) was aborted. ">CommandListener::CommandAborted</a> on the listener if aborted. Note that if a command is near completion, it may finish successfully (or fail) before an abort request is processed. </p>
<p>It is an error to call <a class="el" href="class_command_lib_1_1_command.html#a247cbc7325e3b9d9d7044d449b989aa6" title="Aborts a running command">Abort()</a> on anything other than a top level command. </p>

</div>
</div>
<a class="anchor" id="a6afa9e7eab83d5e59746fe15e295e066"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommandLib::Command::AbortAndWait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The exact same effect as a call to <a class="el" href="class_command_lib_1_1_command.html#a247cbc7325e3b9d9d7044d449b989aa6" title="Aborts a running command">Abort</a> immediately followed by a call to <a class="el" href="class_command_lib_1_1_command.html#adb0d288fa3168a371238b53e3f4a90f7" title="Waits for a running command to complete. Will return immediately if the command is not currently exec...">Wait</a> </p>

</div>
</div>
<a class="anchor" id="aa75bcf85f047a0e986568d134236096d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , typename Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CommandLib::Command::AbortAndWait </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>interval</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The exact same effect as a call to <a class="el" href="class_command_lib_1_1_command.html#a247cbc7325e3b9d9d7044d449b989aa6" title="Aborts a running command">Abort</a> immediately followed by a call to Wait(const std::chrono::duration{Rep, Period}&amp;) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interval</td><td>The maximum amount of time to wait</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the the command completed within 'duration', false otherwise</dd></dl>

</div>
</div>
<a class="anchor" id="ab7e0fd4eb4f1d2b6d98228c1432805e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CommandLib::Command::AbortAndWait </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The exact same effect as a call to <a class="el" href="class_command_lib_1_1_command.html#a247cbc7325e3b9d9d7044d449b989aa6" title="Aborts a running command">Abort</a> immediately followed by a call to Wait(const std::chrono::duration{Rep, Period}&amp;) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds</td><td>The maximum number of milliseconds to wait</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the the command completed within 'duration', false otherwise</dd></dl>

</div>
</div>
<a class="anchor" id="a4f49e49de93e9b4ef3093031b41cc551"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_command_lib_1_1_waitable.html#ac74b6b91e48220146eada76a31cf2d9b">Waitable::Ptr</a> CommandLib::Command::AbortEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signaled when this command is to be aborted. Note that this event is only reset when the command next begins execution. </p>
<dl class="section return"><dt>Returns</dt><dd>The object that can waited up for this command to be signaled to abort.</dd></dl>
<p>Note that this is signaled when the command should abort, which will be before the command finishes aborting itself</p>

</div>
</div>
<a class="anchor" id="a44bad231a0f0a6de3d5405382d95f800"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommandLib::Command::AsyncExecute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_command_lib_1_1_command_listener.html">CommandListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts executing the command and returns immediately. </p>
<p>Call <a class="el" href="class_command_lib_1_1_command.html#adb0d288fa3168a371238b53e3f4a90f7" title="Waits for a running command to complete. Will return immediately if the command is not currently exec...">Wait</a> if you need to block until the command finishes. </p>
<p>It is safe to call this any number of times, but it will cause undefined behavior to re-execute a command that is already executing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>One of the methods of this interface will be called upon completion, on a separate thread. See the <a class="el" href="class_command_lib_1_1_command_listener.html" title="An object implementing this interface is required as a parameter to Command::AsyncExecute(CommandList...">CommandListener</a> documentation for details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb415e0c75ffbda7cb840443ea4ac885"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CommandLib::Command::CheckAbortFlag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throws a <a class="el" href="class_command_lib_1_1_command_aborted_exception.html" title="This is thrown from Command.SyncExecute() when a command is aborted. ">CommandAbortedException</a> if an abort is pending. Synchronous implementations may find this useful in order to respond to an abort request in a timely manner. </p>

</div>
</div>
<a class="anchor" id="a96f8ac531b436a41b21252fa2e17fd79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string CommandLib::Command::ClassName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the name of the runtime instance of this class. Used for logging and diagnostic purposes. </p>
<p>The returned string should be the name of the derived class, without any namespace qualification. I could have used typeid instead, but that requires compiling with RTTI, which is not something that everyone wants. </p>

<p>Implemented in <a class="el" href="class_command_lib_1_1_periodic_command.html#a77c34a0f31ae4e7f0c642a356bd5d6ef">CommandLib::PeriodicCommand</a>, <a class="el" href="class_command_lib_1_1_pause_command.html#afcdddf1fa8b52a3bfec665b1db736cc5">CommandLib::PauseCommand</a>, <a class="el" href="class_command_lib_1_1_recurring_command.html#a4e2073b92185dd5f7b545d774afbb929">CommandLib::RecurringCommand</a>, <a class="el" href="class_command_lib_1_1_scheduled_command.html#ae01bdda88e63460a380579e08ced9eda">CommandLib::ScheduledCommand</a>, <a class="el" href="class_command_lib_1_1_time_limited_command.html#a2a5063ef124f555229b90f7bd82f362e">CommandLib::TimeLimitedCommand</a>, <a class="el" href="class_command_lib_1_1_retryable_command.html#ace5c335248d89b0bf162de17a9579a74">CommandLib::RetryableCommand</a>, <a class="el" href="class_command_lib_1_1_variable_command.html#a20b0247639467cc5a1b5f998218eb57d">CommandLib::VariableCommand</a>, <a class="el" href="class_command_lib_1_1_abort_linked_command.html#a014c2c8177e18e27f651aa122b58c90e">CommandLib::AbortLinkedCommand</a>, <a class="el" href="class_command_lib_1_1_parallel_commands.html#aada3d28f970e82d1d057ac2b499453ac">CommandLib::ParallelCommands</a>, and <a class="el" href="class_command_lib_1_1_sequential_commands.html#abbfd93499d508c3f0d2d817bd59e7080">CommandLib::SequentialCommands</a>.</p>

</div>
</div>
<a class="anchor" id="a84d249e5aecce7e36de8fd4495ae38da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CommandLib::Command::Depth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How deeply nested this command is</p>
<dl class="section return"><dt>Returns</dt><dd>The number of parents until the top level command is reached </dd></dl>
<p>A parent is considered an owner, or the command that an <a class="el" href="class_command_lib_1_1_abort_linked_command.html" title="A Command wrapper that, in addition to responding to normal Command::Abort requests, also aborts in response to either 1) a request to abort a different, specified Command instance, or 2) the signaling of a specified Waitable (typically an Event). ">AbortLinkedCommand</a> is linked to (if any).</p>

</div>
</div>
<a class="anchor" id="a67806612c49e59e3df7310774ca6403b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string CommandLib::Command::Description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A description of the <a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a></p>
<dl class="section return"><dt>Returns</dt><dd>The name of the concrete class of this command, preceded by the names of the classes of each parent, up to the top-level parent. This is followed with this command's unique id (for example, '<a class="el" href="class_command_lib_1_1_sequential_commands.html" title="Represents a collection of Command objects that execute in sequence, wrapped in a Command object...">SequentialCommands</a>=&gt;PauseCommand(23)'). The description ends with details of about the current state of the command, if available. </dd></dl>
<p>A parent is considered the owner, or the command that an <a class="el" href="class_command_lib_1_1_abort_linked_command.html" title="A Command wrapper that, in addition to responding to normal Command::Abort requests, also aborts in response to either 1) a request to abort a different, specified Command instance, or 2) the signaling of a specified Waitable (typically an Event). ">AbortLinkedCommand</a> is linked to (if any). </p>

</div>
</div>
<a class="anchor" id="add579dd7358aa87e722f8b2e9be0afd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_command_lib_1_1_waitable.html#ac74b6b91e48220146eada76a31cf2d9b">Waitable::Ptr</a> CommandLib::Command::DoneEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signaled when this command has finished execution, regardless of whether it succeeded, failed or was aborted. </p>
<dl class="section return"><dt>Returns</dt><dd>The object that can waited up for this command to be not executing.</dd></dl>
<p>Calling <a class="el" href="class_command_lib_1_1_command.html#adb0d288fa3168a371238b53e3f4a90f7" title="Waits for a running command to complete. Will return immediately if the command is not currently exec...">Wait</a> has the same effect as waiting upon the object returned from this method. </p>

</div>
</div>
<a class="anchor" id="a89c23bbfb9fd781210f36a6a76129c77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string CommandLib::Command::ExtendedDescription </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Information about the command (beyond its type and id), if available, for diagnostic purposes. </p>
<dl class="section return"><dt>Returns</dt><dd>Implementations should return information about the current state of the <a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a>, if available. Return an empty string or null if there is no useful state information to report. </dd></dl>
<p>This information is included as part of GetDescription. It is meant for diagnostic purposes. </p>
<p>Implementations must be thread safe, and they must not not throw. </p>

<p>Reimplemented in <a class="el" href="class_command_lib_1_1_periodic_command.html#a330571debdbd7f7b306dd7f2718e84e5">CommandLib::PeriodicCommand</a>, <a class="el" href="class_command_lib_1_1_pause_command.html#a211772cefb139755c74495f190a9a607">CommandLib::PauseCommand</a>, <a class="el" href="class_command_lib_1_1_scheduled_command.html#a3a4da8459441ce57379753e947467025">CommandLib::ScheduledCommand</a>, <a class="el" href="class_command_lib_1_1_time_limited_command.html#aaf7018c66b91a5d1a519325b99dc3f55">CommandLib::TimeLimitedCommand</a>, <a class="el" href="class_command_lib_1_1_parallel_commands.html#a5c079ef465fe007bc3b8e893554c5610">CommandLib::ParallelCommands</a>, and <a class="el" href="class_command_lib_1_1_sequential_commands.html#a8109d8d9b2c4a191cad02164ca173709">CommandLib::SequentialCommands</a>.</p>

</div>
</div>
<a class="anchor" id="a04e911cc1a65438fd78d8d1d81f6faaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long CommandLib::Command::Id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The unique identifier for this command</p>
<dl class="section return"><dt>Returns</dt><dd>The unique identifier for this command. </dd></dl>

</div>
</div>
<a class="anchor" id="a6772eb611b09f4fdb3812fa059d82555"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_command_lib_1_1_command.html">Command</a>* CommandLib::Command::Parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The command under which this command is nested, if any</p>
<dl class="section return"><dt>Returns</dt><dd>The owner, or the command that an <a class="el" href="class_command_lib_1_1_abort_linked_command.html" title="A Command wrapper that, in addition to responding to normal Command::Abort requests, also aborts in response to either 1) a request to abort a different, specified Command instance, or 2) the signaling of a specified Waitable (typically an Event). ">AbortLinkedCommand</a> is linked to (if any). </dd></dl>

</div>
</div>
<a class="anchor" id="ac872e76c74ed573668b60351fd9ffd1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CommandLib::Command::RelinquishOwnership </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_command_lib_1_1_command.html#a3b3e4f00144373299df5c6bb1acc319d">Ptr</a>&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes what used to be an owned command a top-level command.</p>
<p>The caller of this method must be responsible for ensuring that the relinquished command is properly disposed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The command to relinquish ownership. Note that it must currently be a direct child command of this object (not a grandchild, for example)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5d33760ccb927d7f6349c02907ab4ff3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommandLib::Command::SyncExecute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the command and does not return until it finishes.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_command_lib_1_1_command_aborted_exception.html" title="This is thrown from Command.SyncExecute() when a command is aborted. ">CommandAbortedException</a></td><td>Thrown when execution is aborted</td></tr>
    <tr><td class="paramname">std::exception</td><td>Thrown if execution does not complete successfully. </td></tr>
  </table>
  </dd>
</dl>
<p>It is safe to call this any number of times, but it will cause undefined behavior to re-execute a command that is already executing. </p>

</div>
</div>
<a class="anchor" id="a0787e7b79c5424926be5c1c8be1ebb0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CommandLib::Command::TakeOwnership </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_command_lib_1_1_command.html#a3b3e4f00144373299df5c6bb1acc319d">Ptr</a>&#160;</td>
          <td class="paramname"><em>orphan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make this command the owner of the command passed as an argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orphan</td><td>The command to be owned. Only un-owned commands can take a new owner. Allowing other types of owner transfer would invite misuse and the bad behavior that results (e.g. adding the same <a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a> instance to <a class="el" href="class_command_lib_1_1_sequential_commands.html" title="Represents a collection of Command objects that execute in sequence, wrapped in a Command object...">SequentialCommands</a> and <a class="el" href="class_command_lib_1_1_parallel_commands.html" title="Represents a collection of Command objects that execute in parallel, wrapped in a Command object...">ParallelCommands</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adb0d288fa3168a371238b53e3f4a90f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommandLib::Command::Wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for a running command to complete. Will return immediately if the command is not currently executing. </p>

</div>
</div>
<a class="anchor" id="a109ddf04b5f404e5194e5a3c910a378b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , typename Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CommandLib::Command::Wait </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>interval</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits a specified duration for a running command to complete. Will return immediately if the command is not currently executing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interval</td><td>The maximum amount of time to wait</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the the command completed within 'duration', false otherwise</dd></dl>

</div>
</div>
<a class="anchor" id="a18c65836e7c908923127ff9bba6d4d5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CommandLib::Command::Wait </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits the specified milliseconds for a running command to complete. Will return immediately if the command is not currently executing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds</td><td>The maximum number of milliseconds to wait</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the the command completed within 'duration', false otherwise</dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aa4ceb8d85a720bc5d9bac4be3afd7df5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="class_command_lib_1_1_command_monitor.html">CommandMonitor</a>*&gt; CommandLib::Command::sm_monitors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The objects that define command monitoring behavior. Monitoring is meant for logging and diagnostic purposes. </p>
<p>This static member is not thread-safe. Be sure not to change it while any commands are executing. </p>
<p>There are no default monitors. <a class="el" href="class_command_lib_1_1_command_tracer.html" title="Implements CommandMonitor by writing diagnostic information to an output stream. ">CommandTracer</a> and <a class="el" href="class_command_lib_1_1_command_logger.html" title="Implements CommandMonitor by writing diagnostic information to a log file that can be parsed and dyna...">CommandLogger</a> are implementations of <a class="el" href="class_command_lib_1_1_command_monitor.html" title="This is a callback interface for Command starting and finishing events. Its intended use is for loggi...">CommandMonitor</a> that can be used. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>CommandLibForCPP/CommandLib/include/<a class="el" href="_command_8h_source.html">Command.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_command_lib.html">CommandLib</a></li><li class="navelem"><a class="el" href="class_command_lib_1_1_command.html">Command</a></li>
    <li class="footer">Generated on Fri Dec 26 2014 17:11:51 for CommandLibForCPP by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
