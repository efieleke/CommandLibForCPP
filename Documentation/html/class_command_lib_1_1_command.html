<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CommandLib: CommandLib::Command Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CommandLib
   </div>
   <div id="projectbrief">Classes that simplify coordination of asynchronous and synchronous activities</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_command_lib.html">CommandLib</a></li><li class="navelem"><a class="el" href="class_command_lib_1_1_command.html">Command</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_command_lib_1_1_command-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CommandLib::Command Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents an action that can be run synchronously or asynchronously.  
 <a href="class_command_lib_1_1_command.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_command_8h_source.html">Command.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CommandLib::Command:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_command_lib_1_1_command.png" usemap="#CommandLib::Command_map" alt=""/>
  <map id="CommandLib::Command_map" name="CommandLib::Command_map">
<area href="class_command_lib_1_1_async_command.html" title="Represents a Command which is most naturally asynchronous in its implementation. If you inherit from ..." alt="CommandLib::AsyncCommand" shape="rect" coords="0,112,255,136"/>
<area href="class_command_lib_1_1_sequential_commands.html" title="SequentialCommands is a Command object which contains a collection of commands which are run in seque..." alt="CommandLib::SequentialCommands" shape="rect" coords="265,112,520,136"/>
<area href="class_command_lib_1_1_sync_command.html" title="Represents a Command which is most naturally synchronous in its implementation. If you inherit from t..." alt="CommandLib::SyncCommand" shape="rect" coords="530,112,785,136"/>
<area href="class_command_lib_1_1_parallel_commands.html" title="Represents a collection of Command objects that execute in parallel, wrapped in a Command object" alt="CommandLib::ParallelCommands" shape="rect" coords="0,168,255,192"/>
<area href="class_command_lib_1_1_finally_command.html" title="This Command wraps another command, and runs a client-specified command upon either success of failur..." alt="CommandLib::FinallyCommand" shape="rect" coords="795,168,1050,192"/>
<area href="class_command_lib_1_1_pause_command.html" title="A Command that efficiently does nothing for a specified duration." alt="CommandLib::PauseCommand" shape="rect" coords="795,224,1050,248"/>
<area href="class_command_lib_1_1_periodic_command.html" title="Represents a Command that repeats periodically at a specified interval" alt="CommandLib::PeriodicCommand" shape="rect" coords="795,280,1050,304"/>
<area href="class_command_lib_1_1_recurring_command.html" title="Represents a Command that repeatedly executes at times specified by the caller" alt="CommandLib::RecurringCommand" shape="rect" coords="795,336,1050,360"/>
<area href="class_command_lib_1_1_retryable_command.html" title="This Command wraps another command, allowing the command to be retried upon failure,..." alt="CommandLib::RetryableCommand" shape="rect" coords="795,392,1050,416"/>
<area href="class_command_lib_1_1_scheduled_command.html" title="Represents a Command that executes at a given time. When a ScheduledCommand is executed,..." alt="CommandLib::ScheduledCommand" shape="rect" coords="795,448,1050,472"/>
<area href="class_command_lib_1_1_time_limited_command.html" title="This Command wraps another Command, throwing a TimeoutException if a specified interval elapses befor..." alt="CommandLib::TimeLimitedCommand" shape="rect" coords="795,504,1050,528"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aee8fd78ff853a1f9c8e56959c3e81811"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; const <a class="el" href="class_command_lib_1_1_command.html">Command</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#aee8fd78ff853a1f9c8e56959c3e81811">ConstPtr</a></td></tr>
<tr class="memdesc:aee8fd78ff853a1f9c8e56959c3e81811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer to a non-modifyable <a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a> object  <a href="class_command_lib_1_1_command.html#aee8fd78ff853a1f9c8e56959c3e81811">More...</a><br /></td></tr>
<tr class="separator:aee8fd78ff853a1f9c8e56959c3e81811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3e4f00144373299df5c6bb1acc319d"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; <a class="el" href="class_command_lib_1_1_command.html">Command</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a3b3e4f00144373299df5c6bb1acc319d">Ptr</a></td></tr>
<tr class="memdesc:a3b3e4f00144373299df5c6bb1acc319d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer to a <a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a> object  <a href="class_command_lib_1_1_command.html#a3b3e4f00144373299df5c6bb1acc319d">More...</a><br /></td></tr>
<tr class="separator:a3b3e4f00144373299df5c6bb1acc319d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a00a3047609fda3d69b828b7850624389"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a00a3047609fda3d69b828b7850624389">Id</a> () const</td></tr>
<tr class="memdesc:a00a3047609fda3d69b828b7850624389"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unique identifier for this command  <a href="class_command_lib_1_1_command.html#a00a3047609fda3d69b828b7850624389">More...</a><br /></td></tr>
<tr class="separator:a00a3047609fda3d69b828b7850624389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a55aef338aad892fc105b2e1f8700f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_command_lib_1_1_command.html">Command</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a19a55aef338aad892fc105b2e1f8700f">Parent</a> () const</td></tr>
<tr class="memdesc:a19a55aef338aad892fc105b2e1f8700f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The command under which this command is nested, if any  <a href="class_command_lib_1_1_command.html#a19a55aef338aad892fc105b2e1f8700f">More...</a><br /></td></tr>
<tr class="separator:a19a55aef338aad892fc105b2e1f8700f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e3c6c7f6467cbeffe287984c3f012d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a28e3c6c7f6467cbeffe287984c3f012d">Depth</a> () const</td></tr>
<tr class="memdesc:a28e3c6c7f6467cbeffe287984c3f012d"><td class="mdescLeft">&#160;</td><td class="mdescRight">How deeply nested this command is  <a href="class_command_lib_1_1_command.html#a28e3c6c7f6467cbeffe287984c3f012d">More...</a><br /></td></tr>
<tr class="separator:a28e3c6c7f6467cbeffe287984c3f012d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03783e0aea82f820805b8c4e9cc8b43e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a03783e0aea82f820805b8c4e9cc8b43e">Description</a> () const</td></tr>
<tr class="memdesc:a03783e0aea82f820805b8c4e9cc8b43e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A description of the <a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a>  <a href="class_command_lib_1_1_command.html#a03783e0aea82f820805b8c4e9cc8b43e">More...</a><br /></td></tr>
<tr class="separator:a03783e0aea82f820805b8c4e9cc8b43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795a185509e7b0fc1606b3b62fe17fbb"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a795a185509e7b0fc1606b3b62fe17fbb">ExtendedDescription</a> () const</td></tr>
<tr class="memdesc:a795a185509e7b0fc1606b3b62fe17fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the command (beyond its type and id), if available, for diagnostic purposes.  <a href="class_command_lib_1_1_command.html#a795a185509e7b0fc1606b3b62fe17fbb">More...</a><br /></td></tr>
<tr class="separator:a795a185509e7b0fc1606b3b62fe17fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccad987c43709c44c20132c3890b585"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a4ccad987c43709c44c20132c3890b585">IsNaturallySynchronous</a> () const =0</td></tr>
<tr class="memdesc:a4ccad987c43709c44c20132c3890b585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this command's most efficient form of execution is synchronous. This information is used on occasion to determine how to best execute a command.  <a href="class_command_lib_1_1_command.html#a4ccad987c43709c44c20132c3890b585">More...</a><br /></td></tr>
<tr class="separator:a4ccad987c43709c44c20132c3890b585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d33760ccb927d7f6349c02907ab4ff3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a5d33760ccb927d7f6349c02907ab4ff3">SyncExecute</a> ()</td></tr>
<tr class="memdesc:a5d33760ccb927d7f6349c02907ab4ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the command and does not return until it finishes.  <a href="class_command_lib_1_1_command.html#a5d33760ccb927d7f6349c02907ab4ff3">More...</a><br /></td></tr>
<tr class="separator:a5d33760ccb927d7f6349c02907ab4ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663d50889f527a4963eebd88bbcdc522"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a663d50889f527a4963eebd88bbcdc522">SyncExecute</a> (<a class="el" href="class_command_lib_1_1_command.html">Command</a> *owner)</td></tr>
<tr class="memdesc:a663d50889f527a4963eebd88bbcdc522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the command and does not return until it finishes.  <a href="class_command_lib_1_1_command.html#a663d50889f527a4963eebd88bbcdc522">More...</a><br /></td></tr>
<tr class="separator:a663d50889f527a4963eebd88bbcdc522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bad231a0f0a6de3d5405382d95f800"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a44bad231a0f0a6de3d5405382d95f800">AsyncExecute</a> (<a class="el" href="class_command_lib_1_1_command_listener.html">CommandListener</a> *listener)</td></tr>
<tr class="memdesc:a44bad231a0f0a6de3d5405382d95f800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts executing the command and returns immediately.  <a href="class_command_lib_1_1_command.html#a44bad231a0f0a6de3d5405382d95f800">More...</a><br /></td></tr>
<tr class="separator:a44bad231a0f0a6de3d5405382d95f800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247cbc7325e3b9d9d7044d449b989aa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a247cbc7325e3b9d9d7044d449b989aa6">Abort</a> ()</td></tr>
<tr class="memdesc:a247cbc7325e3b9d9d7044d449b989aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts a running command  <a href="class_command_lib_1_1_command.html#a247cbc7325e3b9d9d7044d449b989aa6">More...</a><br /></td></tr>
<tr class="separator:a247cbc7325e3b9d9d7044d449b989aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d49fbf9bbcc543fb57e4b04edf1ddb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#ac4d49fbf9bbcc543fb57e4b04edf1ddb">Wait</a> () const</td></tr>
<tr class="memdesc:ac4d49fbf9bbcc543fb57e4b04edf1ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for a running command to complete. Will return immediately if the command is not currently executing.  <a href="class_command_lib_1_1_command.html#ac4d49fbf9bbcc543fb57e4b04edf1ddb">More...</a><br /></td></tr>
<tr class="separator:ac4d49fbf9bbcc543fb57e4b04edf1ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd3c0e7ee280652c69a3e13a30b99e7"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:a0cd3c0e7ee280652c69a3e13a30b99e7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a0cd3c0e7ee280652c69a3e13a30b99e7">Wait</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;interval) const</td></tr>
<tr class="memdesc:a0cd3c0e7ee280652c69a3e13a30b99e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits a specified duration for a running command to complete. Will return immediately if the command is not currently executing.  <a href="class_command_lib_1_1_command.html#a0cd3c0e7ee280652c69a3e13a30b99e7">More...</a><br /></td></tr>
<tr class="separator:a0cd3c0e7ee280652c69a3e13a30b99e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cae3ab883426e4f872782b8de88597"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#ad4cae3ab883426e4f872782b8de88597">Wait</a> (long long milliseconds) const</td></tr>
<tr class="memdesc:ad4cae3ab883426e4f872782b8de88597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits the specified milliseconds for a running command to complete. Will return immediately if the command is not currently executing.  <a href="class_command_lib_1_1_command.html#ad4cae3ab883426e4f872782b8de88597">More...</a><br /></td></tr>
<tr class="separator:ad4cae3ab883426e4f872782b8de88597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6afa9e7eab83d5e59746fe15e295e066"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a6afa9e7eab83d5e59746fe15e295e066">AbortAndWait</a> ()</td></tr>
<tr class="memdesc:a6afa9e7eab83d5e59746fe15e295e066"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exact same effect as a call to <a class="el" href="class_command_lib_1_1_command.html#a247cbc7325e3b9d9d7044d449b989aa6" title="Aborts a running command">Abort</a> immediately followed by a call to <a class="el" href="class_command_lib_1_1_command.html#ac4d49fbf9bbcc543fb57e4b04edf1ddb" title="Waits for a running command to complete. Will return immediately if the command is not currently exec...">Wait</a>  <a href="class_command_lib_1_1_command.html#a6afa9e7eab83d5e59746fe15e295e066">More...</a><br /></td></tr>
<tr class="separator:a6afa9e7eab83d5e59746fe15e295e066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51df64ba29324bbbbe13c647e708563"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:af51df64ba29324bbbbe13c647e708563"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#af51df64ba29324bbbbe13c647e708563">AbortAndWait</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;interval) const</td></tr>
<tr class="memdesc:af51df64ba29324bbbbe13c647e708563"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exact same effect as a call to <a class="el" href="class_command_lib_1_1_command.html#a247cbc7325e3b9d9d7044d449b989aa6" title="Aborts a running command">Abort</a> immediately followed by a call to Wait(const std::chrono::duration&lt;Rep, Period&gt;&amp;)  <a href="class_command_lib_1_1_command.html#af51df64ba29324bbbbe13c647e708563">More...</a><br /></td></tr>
<tr class="separator:af51df64ba29324bbbbe13c647e708563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e0fd4eb4f1d2b6d98228c1432805e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#ab7e0fd4eb4f1d2b6d98228c1432805e3">AbortAndWait</a> (long long milliseconds)</td></tr>
<tr class="memdesc:ab7e0fd4eb4f1d2b6d98228c1432805e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exact same effect as a call to <a class="el" href="class_command_lib_1_1_command.html#a247cbc7325e3b9d9d7044d449b989aa6" title="Aborts a running command">Abort</a> immediately followed by a call to Wait(const std::chrono::duration&lt;Rep, Period&gt;&amp;)  <a href="class_command_lib_1_1_command.html#ab7e0fd4eb4f1d2b6d98228c1432805e3">More...</a><br /></td></tr>
<tr class="separator:ab7e0fd4eb4f1d2b6d98228c1432805e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f8ac531b436a41b21252fa2e17fd79"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a96f8ac531b436a41b21252fa2e17fd79">ClassName</a> () const =0</td></tr>
<tr class="memdesc:a96f8ac531b436a41b21252fa2e17fd79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of the runtime instance of this class. Used for logging and diagnostic purposes.  <a href="class_command_lib_1_1_command.html#a96f8ac531b436a41b21252fa2e17fd79">More...</a><br /></td></tr>
<tr class="separator:a96f8ac531b436a41b21252fa2e17fd79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f163dafd55fe63a5ed351e1543d02a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_command_lib_1_1_waitable.html#ac74b6b91e48220146eada76a31cf2d9b">Waitable::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a5f163dafd55fe63a5ed351e1543d02a3">DoneEvent</a> () const</td></tr>
<tr class="memdesc:a5f163dafd55fe63a5ed351e1543d02a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signaled when this command has finished execution, regardless of whether it succeeded, failed or was aborted.  <a href="class_command_lib_1_1_command.html#a5f163dafd55fe63a5ed351e1543d02a3">More...</a><br /></td></tr>
<tr class="separator:a5f163dafd55fe63a5ed351e1543d02a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdc8e982866dbbfb763af5d755f76dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_command_lib_1_1_waitable.html#ac74b6b91e48220146eada76a31cf2d9b">Waitable::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a1fdc8e982866dbbfb763af5d755f76dd">AbortEvent</a> () const</td></tr>
<tr class="memdesc:a1fdc8e982866dbbfb763af5d755f76dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signaled when this command is to be aborted. Note that this event is only reset when the command next begins execution.  <a href="class_command_lib_1_1_command.html#a1fdc8e982866dbbfb763af5d755f76dd">More...</a><br /></td></tr>
<tr class="separator:a1fdc8e982866dbbfb763af5d755f76dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aa4ceb8d85a720bc5d9bac4be3afd7df5"><td class="memItemLeft" align="right" valign="top">static std::list&lt; <a class="el" href="class_command_lib_1_1_command_monitor.html">CommandMonitor</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#aa4ceb8d85a720bc5d9bac4be3afd7df5">sm_monitors</a></td></tr>
<tr class="memdesc:aa4ceb8d85a720bc5d9bac4be3afd7df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The objects that define command monitoring behavior. Monitoring is meant for logging and diagnostic purposes.  <a href="class_command_lib_1_1_command.html#aa4ceb8d85a720bc5d9bac4be3afd7df5">More...</a><br /></td></tr>
<tr class="separator:aa4ceb8d85a720bc5d9bac4be3afd7df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a31713edf2ee9c217f9090e5337dd1f44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a31713edf2ee9c217f9090e5337dd1f44">Command</a> ()</td></tr>
<tr class="memdesc:a31713edf2ee9c217f9090e5337dd1f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor  <a href="class_command_lib_1_1_command.html#a31713edf2ee9c217f9090e5337dd1f44">More...</a><br /></td></tr>
<tr class="separator:a31713edf2ee9c217f9090e5337dd1f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0787e7b79c5424926be5c1c8be1ebb0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a0787e7b79c5424926be5c1c8be1ebb0d">TakeOwnership</a> (<a class="el" href="class_command_lib_1_1_command.html#a3b3e4f00144373299df5c6bb1acc319d">Ptr</a> orphan)</td></tr>
<tr class="memdesc:a0787e7b79c5424926be5c1c8be1ebb0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make this command the owner of the command passed as an argument.  <a href="class_command_lib_1_1_command.html#a0787e7b79c5424926be5c1c8be1ebb0d">More...</a><br /></td></tr>
<tr class="separator:a0787e7b79c5424926be5c1c8be1ebb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac872e76c74ed573668b60351fd9ffd1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#ac872e76c74ed573668b60351fd9ffd1d">RelinquishOwnership</a> (<a class="el" href="class_command_lib_1_1_command.html#a3b3e4f00144373299df5c6bb1acc319d">Ptr</a> command)</td></tr>
<tr class="memdesc:ac872e76c74ed573668b60351fd9ffd1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes what used to be an owned command a top-level command.  <a href="class_command_lib_1_1_command.html#ac872e76c74ed573668b60351fd9ffd1d">More...</a><br /></td></tr>
<tr class="separator:ac872e76c74ed573668b60351fd9ffd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9fe77b6976159e86428ebcaeee0e82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a0e9fe77b6976159e86428ebcaeee0e82">CheckAbortFlag</a> () const</td></tr>
<tr class="memdesc:a0e9fe77b6976159e86428ebcaeee0e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws a <a class="el" href="class_command_lib_1_1_command_aborted_exception.html" title="This is thrown from Command.SyncExecute() when a command is aborted.">CommandAbortedException</a> if an abort is pending. Synchronous implementations may find this useful in order to respond to an abort request in a timely manner.  <a href="class_command_lib_1_1_command.html#a0e9fe77b6976159e86428ebcaeee0e82">More...</a><br /></td></tr>
<tr class="separator:a0e9fe77b6976159e86428ebcaeee0e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297473697514edc973b5ca9393f8d404"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#a297473697514edc973b5ca9393f8d404">ResetChildAbortEvent</a> (<a class="el" href="class_command_lib_1_1_command.html#a3b3e4f00144373299df5c6bb1acc319d">Ptr</a> childCommand)</td></tr>
<tr class="memdesc:a297473697514edc973b5ca9393f8d404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the abort event of a command that is owned by this command. Derived implementations may need to call this execute a child command regardless of whether its owner was aborted. This method only exists for special cases.  <a href="class_command_lib_1_1_command.html#a297473697514edc973b5ca9393f8d404">More...</a><br /></td></tr>
<tr class="separator:a297473697514edc973b5ca9393f8d404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8fb1bc11a4421953f83c09ce4247c22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_command_lib_1_1_command.html#ab8fb1bc11a4421953f83c09ce4247c22">AbortChildCommand</a> (<a class="el" href="class_command_lib_1_1_command.html#a3b3e4f00144373299df5c6bb1acc319d">Ptr</a> childCommand)</td></tr>
<tr class="memdesc:ab8fb1bc11a4421953f83c09ce4247c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts a command that is owned by this command. Derived implementations may need to call this to halt an owned command's execution without effecting the execution state of the owning command. Note that when a command is aborted via normal means (via <a class="el" href="class_command_lib_1_1_command.html#a247cbc7325e3b9d9d7044d449b989aa6" title="Aborts a running command">Command.Abort()</a>), all of its owned commands are also aborted. This method only exists for special cases.  <a href="class_command_lib_1_1_command.html#ab8fb1bc11a4421953f83c09ce4247c22">More...</a><br /></td></tr>
<tr class="separator:ab8fb1bc11a4421953f83c09ce4247c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:abff6f12669682d683b4c150859ce09fc"><td class="memItemLeft" align="right" valign="top"><a id="abff6f12669682d683b4c150859ce09fc"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>AsyncCommand</b></td></tr>
<tr class="separator:abff6f12669682d683b4c150859ce09fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents an action that can be run synchronously or asynchronously. </p>
<p>Commands are abortable. Even a synchronously running command can be aborted from a separate thread. </p>
<p><a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a> types are only instantiable via static Create() methods. This is because commands often own other commands. It was necessary to either enforce clone interface support, or enforce working with smart pointers. Smart pointers felt like the easier approach for clients (writing clone methods is a nuisance). </p>
<p>When developing a <a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a> subclass, be sure to inherit from either <a class="el" href="class_command_lib_1_1_sync_command.html" title="Represents a Command which is most naturally synchronous in its implementation. If you inherit from t...">SyncCommand</a> (if your command is naturally synchronous in its implementation) or <a class="el" href="class_command_lib_1_1_async_command.html" title="Represents a Command which is most naturally asynchronous in its implementation. If you inherit from ...">AsyncCommand</a>. Those classes take care of the unnatural implementations (<a class="el" href="class_command_lib_1_1_sync_command.html" title="Represents a Command which is most naturally synchronous in its implementation. If you inherit from t...">SyncCommand</a> implements AsyncExecuteImpl, and <a class="el" href="class_command_lib_1_1_async_command.html" title="Represents a Command which is most naturally asynchronous in its implementation. If you inherit from ...">AsyncCommand</a> implements SyncExecuteImpl). </p>
<p>Also, when developing a <a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a> subclass, make sure that any member variables that are Commands are properly owned by calling <a class="el" href="class_command_lib_1_1_command.html#a0787e7b79c5424926be5c1c8be1ebb0d" title="Make this command the owner of the command passed as an argument.">TakeOwnership</a> within your constructor body. The advantage of doing this is that owned commands will automatically respond to abort requests issued to the owner. </p>
<p>If you write a method that accepts a <a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a> as an argument, you may wish to assume ownership of that <a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a>. <a class="el" href="class_command_lib_1_1_command.html#a0787e7b79c5424926be5c1c8be1ebb0d" title="Make this command the owner of the command passed as an argument.">TakeOwnership</a> allows you to do this. The <a class="el" href="class_command_lib_1_1_sequential_commands.html#af0100e15f7897471ce84802ab6c25e00" title="Adds a Command to the collection to execute.">SequentialCommands::Add</a> member of <a class="el" href="class_command_lib_1_1_sequential_commands.html" title="SequentialCommands is a Command object which contains a collection of commands which are run in seque...">SequentialCommands</a> is an example of this behavior. </p>
<p>Generally speaking, when authoring Commands, it's best to make them as granular as possible. That makes it much easier to reuse them while composing command structures. Also, ensure that your commands are responsive to abort requests if they take a noticeable amount of time to complete. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aee8fd78ff853a1f9c8e56959c3e81811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee8fd78ff853a1f9c8e56959c3e81811">&#9670;&nbsp;</a></span>ConstPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;const <a class="el" href="class_command_lib_1_1_command.html">Command</a>&gt; <a class="el" href="class_command_lib_1_1_command.html#aee8fd78ff853a1f9c8e56959c3e81811">CommandLib::Command::ConstPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared pointer to a non-modifyable <a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a> object </p>

</div>
</div>
<a id="a3b3e4f00144373299df5c6bb1acc319d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b3e4f00144373299df5c6bb1acc319d">&#9670;&nbsp;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;<a class="el" href="class_command_lib_1_1_command.html">Command</a>&gt; <a class="el" href="class_command_lib_1_1_command.html#a3b3e4f00144373299df5c6bb1acc319d">CommandLib::Command::Ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared pointer to a <a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a> object </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a31713edf2ee9c217f9090e5337dd1f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31713edf2ee9c217f9090e5337dd1f44">&#9670;&nbsp;</a></span>Command()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CommandLib::Command::Command </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a247cbc7325e3b9d9d7044d449b989aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247cbc7325e3b9d9d7044d449b989aa6">&#9670;&nbsp;</a></span>Abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommandLib::Command::Abort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aborts a running command </p>
<p>This method will have no effect on a command that is not running (nor will it cause a future execution of this command to abort). Synchronous execution will throw a <a class="el" href="class_command_lib_1_1_command_aborted_exception.html" title="This is thrown from Command.SyncExecute() when a command is aborted.">CommandAbortedException</a> if aborted, and asynchronous execution will invoke <a class="el" href="class_command_lib_1_1_command_listener.html#aa389ff6dd3895ce4ecc9447a23e4d9fc" title="Called when a Command launched via Command::AsyncExecute(CommandListener*) was aborted.">CommandListener::CommandAborted</a> on the listener if aborted. Note that if a command is near completion, it may finish successfully (or fail) before an abort request is processed. </p>
<p>It is an error to call <a class="el" href="class_command_lib_1_1_command.html#a247cbc7325e3b9d9d7044d449b989aa6" title="Aborts a running command">Abort()</a> on anything other than a top level command. </p>

</div>
</div>
<a id="a6afa9e7eab83d5e59746fe15e295e066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6afa9e7eab83d5e59746fe15e295e066">&#9670;&nbsp;</a></span>AbortAndWait() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommandLib::Command::AbortAndWait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The exact same effect as a call to <a class="el" href="class_command_lib_1_1_command.html#a247cbc7325e3b9d9d7044d449b989aa6" title="Aborts a running command">Abort</a> immediately followed by a call to <a class="el" href="class_command_lib_1_1_command.html#ac4d49fbf9bbcc543fb57e4b04edf1ddb" title="Waits for a running command to complete. Will return immediately if the command is not currently exec...">Wait</a> </p>

</div>
</div>
<a id="af51df64ba29324bbbbe13c647e708563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af51df64ba29324bbbbe13c647e708563">&#9670;&nbsp;</a></span>AbortAndWait() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , typename Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CommandLib::Command::AbortAndWait </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>interval</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The exact same effect as a call to <a class="el" href="class_command_lib_1_1_command.html#a247cbc7325e3b9d9d7044d449b989aa6" title="Aborts a running command">Abort</a> immediately followed by a call to Wait(const std::chrono::duration&lt;Rep, Period&gt;&amp;) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interval</td><td>The maximum amount of time to wait</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the the command completed within 'duration', false otherwise</dd></dl>

</div>
</div>
<a id="ab7e0fd4eb4f1d2b6d98228c1432805e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e0fd4eb4f1d2b6d98228c1432805e3">&#9670;&nbsp;</a></span>AbortAndWait() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CommandLib::Command::AbortAndWait </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The exact same effect as a call to <a class="el" href="class_command_lib_1_1_command.html#a247cbc7325e3b9d9d7044d449b989aa6" title="Aborts a running command">Abort</a> immediately followed by a call to Wait(const std::chrono::duration&lt;Rep, Period&gt;&amp;) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds</td><td>The maximum number of milliseconds to wait</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the the command completed within 'duration', false otherwise</dd></dl>

</div>
</div>
<a id="ab8fb1bc11a4421953f83c09ce4247c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8fb1bc11a4421953f83c09ce4247c22">&#9670;&nbsp;</a></span>AbortChildCommand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CommandLib::Command::AbortChildCommand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_command_lib_1_1_command.html#a3b3e4f00144373299df5c6bb1acc319d">Ptr</a>&#160;</td>
          <td class="paramname"><em>childCommand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aborts a command that is owned by this command. Derived implementations may need to call this to halt an owned command's execution without effecting the execution state of the owning command. Note that when a command is aborted via normal means (via <a class="el" href="class_command_lib_1_1_command.html#a247cbc7325e3b9d9d7044d449b989aa6" title="Aborts a running command">Command.Abort()</a>), all of its owned commands are also aborted. This method only exists for special cases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">childCommand</td><td>The owned command. This must be an immediate child (not a grandchild, for example).</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1fdc8e982866dbbfb763af5d755f76dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fdc8e982866dbbfb763af5d755f76dd">&#9670;&nbsp;</a></span>AbortEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_command_lib_1_1_waitable.html#ac74b6b91e48220146eada76a31cf2d9b">Waitable::Ptr</a> CommandLib::Command::AbortEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signaled when this command is to be aborted. Note that this event is only reset when the command next begins execution. </p>
<dl class="section return"><dt>Returns</dt><dd>The object that can waited up for this command to be signaled to abort.</dd></dl>
<p>Note that this is signaled when the command should abort, which will be before the command finishes aborting itself</p>

</div>
</div>
<a id="a44bad231a0f0a6de3d5405382d95f800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44bad231a0f0a6de3d5405382d95f800">&#9670;&nbsp;</a></span>AsyncExecute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommandLib::Command::AsyncExecute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_command_lib_1_1_command_listener.html">CommandListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts executing the command and returns immediately. </p>
<p>Call <a class="el" href="class_command_lib_1_1_command.html#ac4d49fbf9bbcc543fb57e4b04edf1ddb" title="Waits for a running command to complete. Will return immediately if the command is not currently exec...">Wait</a> if you need to block until the command finishes. </p>
<p>It is safe to call this any number of times, but it will cause undefined behavior to re-execute a command that is already executing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>One of the methods of this interface will be called upon completion, on a separate thread. See the <a class="el" href="class_command_lib_1_1_command_listener.html" title="An object implementing this interface is required as a parameter to Command::AsyncExecute(CommandList...">CommandListener</a> documentation for details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e9fe77b6976159e86428ebcaeee0e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9fe77b6976159e86428ebcaeee0e82">&#9670;&nbsp;</a></span>CheckAbortFlag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CommandLib::Command::CheckAbortFlag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throws a <a class="el" href="class_command_lib_1_1_command_aborted_exception.html" title="This is thrown from Command.SyncExecute() when a command is aborted.">CommandAbortedException</a> if an abort is pending. Synchronous implementations may find this useful in order to respond to an abort request in a timely manner. </p>

</div>
</div>
<a id="a96f8ac531b436a41b21252fa2e17fd79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f8ac531b436a41b21252fa2e17fd79">&#9670;&nbsp;</a></span>ClassName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string CommandLib::Command::ClassName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the name of the runtime instance of this class. Used for logging and diagnostic purposes. </p>
<p>The returned string should be the name of the derived class, without any namespace qualification. I could have used typeid instead, but that requires compiling with RTTI, which is not something that everyone wants. </p>

<p>Implemented in <a class="el" href="class_command_lib_1_1_time_limited_command.html#a2a5063ef124f555229b90f7bd82f362e">CommandLib::TimeLimitedCommand</a>, <a class="el" href="class_command_lib_1_1_sequential_commands.html#abbfd93499d508c3f0d2d817bd59e7080">CommandLib::SequentialCommands</a>, <a class="el" href="class_command_lib_1_1_scheduled_command.html#ae01bdda88e63460a380579e08ced9eda">CommandLib::ScheduledCommand</a>, <a class="el" href="class_command_lib_1_1_retryable_command.html#ace5c335248d89b0bf162de17a9579a74">CommandLib::RetryableCommand</a>, <a class="el" href="class_command_lib_1_1_recurring_command.html#a4e2073b92185dd5f7b545d774afbb929">CommandLib::RecurringCommand</a>, <a class="el" href="class_command_lib_1_1_periodic_command.html#a77c34a0f31ae4e7f0c642a356bd5d6ef">CommandLib::PeriodicCommand</a>, <a class="el" href="class_command_lib_1_1_pause_command.html#afcdddf1fa8b52a3bfec665b1db736cc5">CommandLib::PauseCommand</a>, <a class="el" href="class_command_lib_1_1_parallel_commands.html#aada3d28f970e82d1d057ac2b499453ac">CommandLib::ParallelCommands</a>, and <a class="el" href="class_command_lib_1_1_finally_command.html#a91108eb6d3af7cf595c6c9fccc82fa49">CommandLib::FinallyCommand</a>.</p>

</div>
</div>
<a id="a28e3c6c7f6467cbeffe287984c3f012d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e3c6c7f6467cbeffe287984c3f012d">&#9670;&nbsp;</a></span>Depth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CommandLib::Command::Depth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How deeply nested this command is </p>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">The number of parents until the top level command is reached</p>
<p class="enddd"></p>
</dd></dl>
<p>A parent is considered the owner</p>

</div>
</div>
<a id="a03783e0aea82f820805b8c4e9cc8b43e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03783e0aea82f820805b8c4e9cc8b43e">&#9670;&nbsp;</a></span>Description()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string CommandLib::Command::Description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A description of the <a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a> </p>
<dl class="section return"><dt>Returns</dt><dd>The name of the concrete class of this command, preceded by the names of the classes of each parent, up to the top-level parent. This is followed with this command's unique id (for example, '<a class="el" href="class_command_lib_1_1_sequential_commands.html" title="SequentialCommands is a Command object which contains a collection of commands which are run in seque...">SequentialCommands</a>=&gt;PauseCommand(23)'). The description ends with details of about the current state of the command, if available. </dd></dl>
<p>A parent is considered the owner </p>

</div>
</div>
<a id="a5f163dafd55fe63a5ed351e1543d02a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f163dafd55fe63a5ed351e1543d02a3">&#9670;&nbsp;</a></span>DoneEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_command_lib_1_1_waitable.html#ac74b6b91e48220146eada76a31cf2d9b">Waitable::Ptr</a> CommandLib::Command::DoneEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signaled when this command has finished execution, regardless of whether it succeeded, failed or was aborted. </p>
<dl class="section return"><dt>Returns</dt><dd>The object that can waited up for this command to be not executing.</dd></dl>
<p>Calling <a class="el" href="class_command_lib_1_1_command.html#ac4d49fbf9bbcc543fb57e4b04edf1ddb" title="Waits for a running command to complete. Will return immediately if the command is not currently exec...">Wait</a> has the same effect as waiting upon the object returned from this method. </p>

</div>
</div>
<a id="a795a185509e7b0fc1606b3b62fe17fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795a185509e7b0fc1606b3b62fe17fbb">&#9670;&nbsp;</a></span>ExtendedDescription()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string CommandLib::Command::ExtendedDescription </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Information about the command (beyond its type and id), if available, for diagnostic purposes. </p>
<dl class="section return"><dt>Returns</dt><dd>Implementations should return information about the current state of the <a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a>, if available. Return an empty string or null if there is no useful state information to report. </dd></dl>
<p>This information is included as part of GetDescription. It is meant for diagnostic purposes. </p>
<p>Implementations must be thread safe, and they must not not throw. </p>

<p>Reimplemented in <a class="el" href="class_command_lib_1_1_time_limited_command.html#aaf7018c66b91a5d1a519325b99dc3f55">CommandLib::TimeLimitedCommand</a>, <a class="el" href="class_command_lib_1_1_sequential_commands.html#a8109d8d9b2c4a191cad02164ca173709">CommandLib::SequentialCommands</a>, <a class="el" href="class_command_lib_1_1_scheduled_command.html#a3a4da8459441ce57379753e947467025">CommandLib::ScheduledCommand</a>, <a class="el" href="class_command_lib_1_1_periodic_command.html#a330571debdbd7f7b306dd7f2718e84e5">CommandLib::PeriodicCommand</a>, <a class="el" href="class_command_lib_1_1_pause_command.html#a211772cefb139755c74495f190a9a607">CommandLib::PauseCommand</a>, and <a class="el" href="class_command_lib_1_1_parallel_commands.html#a5c079ef465fe007bc3b8e893554c5610">CommandLib::ParallelCommands</a>.</p>

</div>
</div>
<a id="a00a3047609fda3d69b828b7850624389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a3047609fda3d69b828b7850624389">&#9670;&nbsp;</a></span>Id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long CommandLib::Command::Id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The unique identifier for this command </p>
<dl class="section return"><dt>Returns</dt><dd>The unique identifier for this command. </dd></dl>

</div>
</div>
<a id="a4ccad987c43709c44c20132c3890b585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ccad987c43709c44c20132c3890b585">&#9670;&nbsp;</a></span>IsNaturallySynchronous()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool CommandLib::Command::IsNaturallySynchronous </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this command's most efficient form of execution is synchronous. This information is used on occasion to determine how to best execute a command. </p>
<dl class="section return"><dt>Returns</dt><dd>true, if this command is most efficient when run synchronously</dd></dl>

<p>Implemented in <a class="el" href="class_command_lib_1_1_sync_command.html#a7541276e393c002979ed54523116b12e">CommandLib::SyncCommand</a>, <a class="el" href="class_command_lib_1_1_sequential_commands.html#a47c2a881bfeab639064e36d202e32e0f">CommandLib::SequentialCommands</a>, and <a class="el" href="class_command_lib_1_1_async_command.html#a2c08165637770cc7bb8fdd814a93acec">CommandLib::AsyncCommand</a>.</p>

</div>
</div>
<a id="a19a55aef338aad892fc105b2e1f8700f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a55aef338aad892fc105b2e1f8700f">&#9670;&nbsp;</a></span>Parent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_command_lib_1_1_command.html">Command</a>* CommandLib::Command::Parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The command under which this command is nested, if any </p>
<dl class="section return"><dt>Returns</dt><dd>The owning <a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a>. </dd></dl>

</div>
</div>
<a id="ac872e76c74ed573668b60351fd9ffd1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac872e76c74ed573668b60351fd9ffd1d">&#9670;&nbsp;</a></span>RelinquishOwnership()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CommandLib::Command::RelinquishOwnership </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_command_lib_1_1_command.html#a3b3e4f00144373299df5c6bb1acc319d">Ptr</a>&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes what used to be an owned command a top-level command. </p>
<p>The caller of this method must be responsible for ensuring that the relinquished command is properly disposed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The command to relinquish ownership. Note that it must currently be a direct child command of this object (not a grandchild, for example)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a297473697514edc973b5ca9393f8d404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297473697514edc973b5ca9393f8d404">&#9670;&nbsp;</a></span>ResetChildAbortEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CommandLib::Command::ResetChildAbortEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_command_lib_1_1_command.html#a3b3e4f00144373299df5c6bb1acc319d">Ptr</a>&#160;</td>
          <td class="paramname"><em>childCommand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the abort event of a command that is owned by this command. Derived implementations may need to call this execute a child command regardless of whether its owner was aborted. This method only exists for special cases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">childCommand</td><td>The owned command. This must be an immediate child (not a grandchild, for example).</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d33760ccb927d7f6349c02907ab4ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d33760ccb927d7f6349c02907ab4ff3">&#9670;&nbsp;</a></span>SyncExecute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommandLib::Command::SyncExecute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the command and does not return until it finishes. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_command_lib_1_1_command_aborted_exception.html" title="This is thrown from Command.SyncExecute() when a command is aborted.">CommandAbortedException</a></td><td>Thrown when execution is aborted</td></tr>
    <tr><td class="paramname">std::exception</td><td>Thrown if execution does not complete successfully. </td></tr>
  </table>
  </dd>
</dl>
<p>It is safe to call this any number of times, but it will cause undefined behavior to re-execute a command that is already executing. </p>

</div>
</div>
<a id="a663d50889f527a4963eebd88bbcdc522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a663d50889f527a4963eebd88bbcdc522">&#9670;&nbsp;</a></span>SyncExecute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommandLib::Command::SyncExecute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_command_lib_1_1_command.html">Command</a> *&#160;</td>
          <td class="paramname"><em>owner</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the command and does not return until it finishes. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_command_lib_1_1_command_aborted_exception.html" title="This is thrown from Command.SyncExecute() when a command is aborted.">CommandAbortedException</a></td><td>Thrown when execution is aborted</td></tr>
    <tr><td class="paramname">std::exception</td><td>Thrown if execution does not complete successfully. </td></tr>
  </table>
  </dd>
</dl>
<p>It is safe to call this any number of times, but it will cause undefined behavior to re-execute a command that is already executing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">owner</td><td>If you want this command to pay attention to abort requests of a different command, set this value to that command. Note that if this <a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a> is already assigned an owner, passing a non-null value will raise an exception. Also note that the owner assignment is only in effect during the scope of this call. Upon return, this command will not have an owner. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0787e7b79c5424926be5c1c8be1ebb0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0787e7b79c5424926be5c1c8be1ebb0d">&#9670;&nbsp;</a></span>TakeOwnership()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CommandLib::Command::TakeOwnership </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_command_lib_1_1_command.html#a3b3e4f00144373299df5c6bb1acc319d">Ptr</a>&#160;</td>
          <td class="paramname"><em>orphan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make this command the owner of the command passed as an argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orphan</td><td>The command to be owned. Only un-owned commands can take a new owner. Allowing other types of owner transfer would invite misuse and the bad behavior that results (e.g. adding the same <a class="el" href="class_command_lib_1_1_command.html" title="Represents an action that can be run synchronously or asynchronously.">Command</a> instance to <a class="el" href="class_command_lib_1_1_sequential_commands.html" title="SequentialCommands is a Command object which contains a collection of commands which are run in seque...">SequentialCommands</a> and <a class="el" href="class_command_lib_1_1_parallel_commands.html" title="Represents a collection of Command objects that execute in parallel, wrapped in a Command object">ParallelCommands</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4d49fbf9bbcc543fb57e4b04edf1ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d49fbf9bbcc543fb57e4b04edf1ddb">&#9670;&nbsp;</a></span>Wait() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CommandLib::Command::Wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for a running command to complete. Will return immediately if the command is not currently executing. </p>

</div>
</div>
<a id="a0cd3c0e7ee280652c69a3e13a30b99e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cd3c0e7ee280652c69a3e13a30b99e7">&#9670;&nbsp;</a></span>Wait() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , typename Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CommandLib::Command::Wait </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>interval</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits a specified duration for a running command to complete. Will return immediately if the command is not currently executing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interval</td><td>The maximum amount of time to wait</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the the command completed within 'duration', false otherwise</dd></dl>

</div>
</div>
<a id="ad4cae3ab883426e4f872782b8de88597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4cae3ab883426e4f872782b8de88597">&#9670;&nbsp;</a></span>Wait() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CommandLib::Command::Wait </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits the specified milliseconds for a running command to complete. Will return immediately if the command is not currently executing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds</td><td>The maximum number of milliseconds to wait</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the the command completed within 'duration', false otherwise</dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa4ceb8d85a720bc5d9bac4be3afd7df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ceb8d85a720bc5d9bac4be3afd7df5">&#9670;&nbsp;</a></span>sm_monitors</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="class_command_lib_1_1_command_monitor.html">CommandMonitor</a>*&gt; CommandLib::Command::sm_monitors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The objects that define command monitoring behavior. Monitoring is meant for logging and diagnostic purposes. </p>
<p>This static member is not thread-safe. Be sure not to change it while any commands are executing. </p>
<p>There are no default monitors. <a class="el" href="class_command_lib_1_1_command_tracer.html" title="Implements CommandMonitor by writing diagnostic information to an output stream.">CommandTracer</a> and <a class="el" href="class_command_lib_1_1_command_logger.html" title="Implements CommandMonitor by writing diagnostic information to a log file that can be parsed and dyna...">CommandLogger</a> are implementations of <a class="el" href="class_command_lib_1_1_command_monitor.html" title="This is a callback interface for Command starting and finishing events. Its intended use is for loggi...">CommandMonitor</a> that can be used. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/efiel/source/repos/efieleke/CommandLibForCPP/CommandLib/include/<a class="el" href="_command_8h_source.html">Command.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
